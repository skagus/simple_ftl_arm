
# Motivation
RTOS는 FW개발에 많은 도움은 준다. 하지만, 세간에는 RTOS로 인한 성능 감소나 자원(SRAM) 사용량 증가로 인하여 그 사용이 꺼려지는 경우가 종종 있는 것 같다. 

RTOS의 사용에 있어서 task당 할당되는 stack은 non-RTOS 환경 대비 약점인 것은 분명하나, 성능 감소는 정확히 증명하기가 곤란한 부분이 있다. 
RTOS를 적용하는 경우, function의 개수나 call 깊이를 더 얕게 가져갈 수도 있기 때문에 이로 인한 성능향상도 가능할 수 있다. 반대로 contex switching은 일반적으로 function call 보다 더 시간이 오래 걸리기 때문에 성능 감소 요인이 될 수도 있다.

본 실험은 이러한 의심을 해소하기 위해서 어느 정도되는 규모의 project에서 그 영향을 관찰하려는 목적으로 수행되었다. 이 프로젝트는 logic 부분만 대략 3000라인 정도로 중형 project라고 볼 수 있기 때문에, 앞서 설명한 문제의 분석을 위해 적당한 크기로 생각된다.

# 실험 방법
두개의 project는 정확히 같은 역할을 하지만, OS(non-RT)위에 구현한 것과 FSM으로 구현한 것이다. (다른 branch에 FSM 으로 구현된 것이 있다.)

성능 비교를 위해서는 실제 target이 필요하기 때문에, 많이 사용되는 stm32f103(cortex m3) board를 사용하였고, build tool은 Arm GUN Toolchain 12.3.Rel1을 사용하였다.

Project대상인 FTL의 구현은 최대한 단순하게 하였으며, 실제 NAND가 없기 때문에 memory상에서 spare 값만 관리하였다. rebuild는 지원이 안되기 때문에, test 시작시 format을 하며, 이 시간은 측정하지 않았다.
성능 측정 내용은, SW, SR, RR, RW 를 모두 진행하였으며, RW의 경우, GC가 없는 초기 성능을 보기 위해서 짧게 나누어서 여러번 수행하였다. 

os와 fsm 공히 compile option은 동일하며, optimize level만 바꿔어 가면서 test하였다. 

# 실험 결과
결과는 시나리오가 수행된 시간을 나타낸 것이기 때문에 값이 클 수록 낮은 성능을 나타낸다.

결과: OS,FSM,Ratio(1보다 크면, FSM이 우위)

|최적화|O0|O2|O3|Ofast|O3 lto|Ofast lto|  |O0|O2|O3|Ofast|O3 lto|Ofast lto|   |O0|O2|O3|Ofast|O3 lto|Ofast lto|
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
|SW|2147709|917362|850010|822584|687132|709326||2254394|973944|877767|877722|709640|723326||0.953|0.942|0.968|0.937|0.968|0.981|
|SR:|1707154|685921|617076|595192|491502|495030||1730384|692377|605878|605869|490488|487836||0.987|0.991|1.018|0.982|1.002|1.015|
|RR:|1737495|714655|645501|623584|528267|529795||1758025|720043|633816|633857|518101|516554||0.988|0.993|1.018|0.984|1.020|1.026|
|RW:|363669|158604|147261|143558|123607|126780||407557|182368|170955|170957|134925|138341||0.892|0.870|0.861|0.840|0.916|0.916|
|RW:|1132928|500053|466143|454971|375596|386241||1039920|446155|429776|429778|323012|328798||1.089|1.121|1.085|1.059|1.163|1.175|
|RW:|1561083|688804|642696|627151|515164|529697||1534866|649980|624748|624758|467189|474286||1.017|1.060|1.029|1.004|1.103|1.117|
|RW:|1488305|657137|612994|597927|491460|505085||1516863|643108|618100|618138|462492|469555||0.981|1.022|0.992|0.967|1.063|1.076|
|RW:|1305535|574653|535574|522510|430421|441975||1252628|531432|511284|511282|382744|388440||1.042|1.081|1.048|1.022|1.125|1.138|
|RW:|1462765|646222|602764|587947|482872|496274||1396552|593377|570538|570538|427232|433921||1.047|1.089|1.056|1.031|1.130|1.144|
|RW:|1410548|623190|581005|566553|465474|478118||1416704|601330|578102|578113|432754|439437||0.996|1.036|1.005|0.980|1.076|1.088|
|RW:|1491993|660868|616625|601556|494290|508468||1238472|528627|508500|508515|381849|388144||1.205|1.250|1.213|1.183|1.294|1.310|
|Sum|15809184|6827469|6317649|6143533|5085785|5206789||15546365|6562741|6129464|6129527|4730426|4788638||1.017|1.040|1.031|1.002|1.075|1.087|

가장 오른쪽의 소수점 표시된 결과는 OS와 FSM의 성능비를 나타낸 것으로, FSM의 성능이 높을 경우, 1이상을 나타내고 있다.

전체적으로 FSM이 약 9% 고성능을 보여주고 있다. 특히 LTO가 적용된 이후에 그 차이가 확연히 드러나고 있다. OS가 결합되면 context change로 인하여, optimize가 잘 안되기 때문인 것 같다.

그리고, O3 lto가 Ofast lto보다 더 성능이 좋게 나타나고 있다.

# 추가 실험

추가 실험으로, OS의 task 관리를 현재 structure of array로 구성되어 있는데, 
이를 array of structure로 변경하여 성능을 측정하였다. 이 실험에서는 structure of array가 성능이 더 높게 나타났다. 
하지만, 이러한 구조 변경이 FSM에서는 반대의 결과를 보여줬다. 
결국, structure of array나 array of structure는 큰 영향이 없는 것으로 보인다.

# 추가 결과
성능 편차 이외에 binary size(RAM사용량)에 대해서는 아래와 같은 결과가 나왔다.

|opt|OS|FSM|ratio|
|---|---|---|---|
|O0|22864|25540|0.895|
|Os|14740|15912|0.926|
|Os lto|13356|14664|0.911|
|O2|16056|17220|0.932|
|O3|17864|18556|0.963|
|O3 lto|21560|22072|0.977|
|Ofast|17620|18556|0.950|
|Ofast lto|21260|21892|0.971|

전체적으로 FSM의 코드 사이즈가 더 큰 것으로 나타나고 있다. 앞서 예측했듯이, C/C++ 코드 자체가 간결해진 덕분에 binary 크기도 줄어든 것으로 보인다. 

또한 LTO의 효과는 Os 와 함께 쓰인 경우, code크기 감소쪽으로 효과가 집중되는 것으로 보인다.

참고로 Os와 lto가 같이 사용되는 경우는 Os보다 code size도 작고 성능도 더 뛰어난 결과가 나타났다.

